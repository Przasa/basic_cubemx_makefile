::::::::::::::::::::::::::::PRZEBIEG POCZATKOWY::::::::::::::::::::::::::::::
Makefile.m
    ->startup_stm32f103xb.c:'Reset_Handler_C()'
        ->system_stm32f1xx.c:'SystemInit()'

1. MakeFile kompiluje pliki wskazane od MakeFile.m
2. Uruchamiany jest startup_stm32f103xb.c (przedtem byl w asseblerze) 
    a) uruchamiane jest pierwsze przerwanei z wektora tablic: 'Reset_Handler_C()'
3. 'Reset_Handler_C()': 
    a) tam inicjowane sa segmeny danych (data, bss, sbss itp.)
    b) "SystemInit()" ; (include z system_stm32f1xx.c)
        - ustawnia clockow (dorzucone kilka zminnych w my_stm32f103xx.h)
    c) __libc_init_arrau(); inijowanie wektora przerwan: 
    c) wywalnie funkcji main (chociaz nie wiem skad)

1. :::::::::::::::::::::::::::REJESTRY POTRZEBNE DLA system_stm32f1xx.h::::::::::::::::::::::::::::)
RESET  =0
HSI_VALUE   (jest w systemie)
HSE_VALUE   (jest w systemie)
RCC->CFGR & RCC_CFGR_SWS        (0x3UL << 2U)
RCC->CFGR & RCC_CFGR_PLLMULL    (0xFUL << 18U)
RCC->CFGR & RCC_CFGR_PLLSRC     (0x1UL << 16U)
RCC->CFGR & RCC_CFGR_PLLXTPRE   (0x1UL << 17U)   
RCC->CFGR & RCC_CFGR_HPRE       (0xFUL << 4U)


2. ::::::::::::::::::::::::::::GPIO (norm)::::::::::::::::::::::::::::::
/**
CNFy[1:0]: Port x configuration bits (y= 0 .. 7)
These bits are written by software to configure the corresponding I/O port.
Refer to Table 20: Port bit configuration table on page 156.
In input mode (MODE[1:0]=00):
    00: Analog mode
    01: Floating input (reset state)
    10: Input with pull-up / pull-down
    11: Reserved
In output mode (MODE[1:0] > 00):
    00: General purpose output push-pull
    01: General purpose output Open-drain
    10: Alternate function output Push-pull
    11: Alternate function output Open-drain

MODEy[1:0]: Port x mode bits (y= 0 .. 7)
These bits are written by software to configure the corresponding I/O port.
Refer to Table 20: Port bit configuration table on page 156.
    00: Input mode (reset state)
    01: Output mode, max speed 10 MHz.
    10: Output mode, max speed 2 MHz.
    11: Output mode, max speed 50 MHz.
*/


3. :::::::::::::::::::::::::::EVENTS/INTERRUPTS:::::::::::::::::::::::::::: *(eventy nie generuja przerwania)
    Hardware interrupt selection
To configure the 20 lines as interrupt sources, use the following procedure:
● Configure the mask bits of the 20 Interrupt lines (EXTI_IMR)
● Configure the Trigger Selection bits of the Interrupt lines (EXTI_RTSR and
EXTI_FTSR)
● Configure the enable and mask bits that control the NVIC IRQ channel mapped to the
External Interrupt Controller (EXTI) so that an interrupt coming from one of the 20 lines
can be correctly acknowledged.
    Hardware event selection
To configure the 20 lines as event sources, use the following procedure:
● Configure the mask bits of the 20 Event lines (EXTI_EMR)
● Configure the Trigger Selection bits of the Event lines (EXTI_RTSR and EXTI_FTSR)
    Software interrupt/event selection
The 20 lines can be configured as software interrupt/event lines. The following is the
procedure to generate a software interrupt.
● Configure the mask bits of the 20 Interrupt/Event lines (EXTI_IMR, EXTI_EMR)
● Set the required bit of the software interrupt register (EXTI_SWIER)

    czyli:
    a) AFIO_EXTICRx         -> przypisania interrupta do gpio
    b) EXTI_IMR             -> ktora linia interrupt
    c) EXTI_RTSR EXTI_FTSR  -> typ zbocza interrupt
    d) NVIC IRQ channel     -> podlaczenie interrupt do wektora obslugi przerwan 
                               eventy (nie interrupty) chya nie korzystaja z NVICa.

External interrupt configuration register 1 (AFIO_EXTICR1)
:::::NOTE!: jednen nr interrupta (0:15), mzoe byc przypisane do tylko jednoe portu (np. EXTI5 -> GPIOC)
    9.4.4 External interrupt configuration register 2 (AFIO_EXTICR2)
    EXTI3[3:0] EXTI2[3:0] EXTI1[3:0] EXTI0[3:0]
    Bits 31:16 Reserved
    Bits 15:0 EXTIx[3:0]: EXTI x configuration (x= 0 to 3)
    These bits are written by software to select the source input for EXTIx external interrupt.
    Refer to Section 10.2.5: External interrupt/event line mapping on page 200
    0000: PA[x] pin
    0001: PB[x] pin
    0010: PC[x] pin
    0011: PD[x] pin
    0100: PE[x] pin
    0101: PF[x] pin
    0110: PG[x] pin
Interrupt mask register (EXTI_IMR)
    0: Interrupt request from Line x is masked
    1: Interrupt request from Line x is not masked
Rising trigger selection register (EXTI_RTSR)
    0: Rising trigger disabled (for Event and Interrupt) for input line
    1: Rising trigger enabled (for Event and Interrupt) for input line.
Falling trigger selection register (EXTI_FTSR)
    0: Falling trigger disabled (for Event and Interrupt) for input line
    1: Falling trigger enabled (for Event and Interrupt) for input line.
NVIC:
The base address of the main NVIC register block is 0xE000E100. The NVIC_STIR register is located in a separate block at 0xE000EF00.
//TODO: 20.03.2021: UZUPELNIJ

Hardware interrupt selection
To configure the 20 lines as interrupt sources, use the following procedure:
● Configure the mask bits of the 20 Interrupt lines (EXTI_IMR)
● Configure the Trigger Selection bits of the Interrupt lines (EXTI_RTSR and
EXTI_FTSR)
● Configure the enable and mask bits that control the NVIC IRQ channel mapped to the
External Interrupt Controller (EXTI) so that an interrupt coming from one of the 20 lines
can be correctly acknowledged.

Hardware event selection
To configure the 20 lines as event sources, use the following procedure:
● Configure the mask bits of the 20 Event lines (EXTI_EMR)
● Configure the Trigger Selection bits of the Event lines (EXTI_RTSR and EXTI_FTSR)

Software interrupt/event selection
The 20 lines can be configured as software interrupt/event lines. The following is the
procedure to generate a software interrupt.
● Configure the mask bits of the 20 Interrupt/Event lines (EXTI_IMR, EXTI_EMR)
● Set the required bit of the software interrupt register (EXTI_SWIER)

2. ::::::::::::::::::::::::::::SPI:::::::::::::::::::::::::::::::::::::::::
bref:
0) wlaczenie clocka: (to check)
a) AFIO_MAPR[0] (lepiej zero) 
    0: No remap (NSS/PA4, SCK/PA5, MISO/PA6, MOSI/PA7)
    1: Remap (NSS/PA15, SCK/PB3, MISO/PB4, MOSI/PB5)
b) ustawianie GPIOsow 
    (pod full duplex)
    master: SCK: alt.pp. MOSI: alt.pp. MISO: in.float/in.pp, NSS: (HW_M) alt.pp. (HW_MS) in.float/in.pu/in.pd 
    slave:  SCK: in.float. MOSI: in.flaot/ in.pp MISO: alt.pp., NSS: (HW_MS) in.float/in.pu/in.pd
    (simplex)
    master: SCK: alt.pp, MOSI: alt.pp, MISO: -, NSS: (HW_M) alt.pp. (HW_MS) in.float/in.pu/in.pd 
    slave: SCK: in.float, MOSI: -, MISO: alt.pp, NSS: (HW_MS): in.float/in.pu/in.pd
c) rejestry SPI: 
    SPI_CR1:  master: BR[2:0]=xy, SPI_CPOL=xx,CPHA=xx, DFF = 16/8 bit, LSBFIRST, SSM=1, SSI=1, SSOE=1 (if req in outmode), MSTR=1, SPE=1
    SPI_CR1:  slave: DFF, CPOL, CPHA, LSBFIRST, [hw]NSS(hwmode), SSM(softmode)=1,SS1=0, MSTR=0, SPE=1
    CPI_CR2:  master: SSOE: 0= SS output disabled (multimaster allowed), 1=ss output enabled (mm not allwed)
d)  tryby pracy:
    full-duplex: BIDIMODE=0, RXONLY=0
    simplex_transmit: BIDIMODE=0, RXONLY=0; (jw)
    simplex_rec-only: BIDIMODE=0, RXONLY=1
    half-duplex: (bidi)
        bidi trans:    BIDIMODE=1, BIDIOE=1 
        bidi rec:      BIDIMODE=1, BIDIOE=0;
e)  wysylanie/obieranie: master: TXE=1 => mozesz wrzucac do SPI_DR, slave: RXNE=1 => mozesz czytac z SPI_DR, BIDIOE=kierunek Bidi, jeszce BSY (szczegolnie przed wylaczenie)
f) interrupts: TODO 20.03.2021 

Table 25. SPI (GPIO inputs)
SPI pinout Configuration GPIO configuration
SPIx_SCK:   Master;                                                     Alternate function push-pull
            Slave;                                                      Input floating
SPIx_MOSI:  Full duplex / master:                                       Alternate function push-pull
            Full duplex / slave:                                        Input floating / Input pull-up
            Simplex bidirectional data wire / master:                   Alternate function push-pull
            Simplex bidirectional data wire/ slave:                     Not used. Can be used as a GPIO
SPIx_MISO:  Full duplex / master:                                       Input floating / Input pull-up
            Full duplex / slave (point to point):                       Alternate function push-pull
            Full duplex / slave (multi-slave):                          Alternate function open drain
            Simplex bidirectional data wire / master:                   Not used. Can be used as a GPIO
            Simplex bidirectional data wire/ slave (point to point):    Alternate function push-pull
            Simplex bidirectional data wire/ slave (multi-slave):       Alternate function open drain
SPIx_NSS:   Hardware master /slave:                                     Input floating/ Input pull-up / Input pull-down "comm":NSS jako input (jako master i jako slave)
            Hardware master/ NSS output enabled:                        Alternate function push-pull
            Software:                                                   Not used. Can be used as a GPIO

TODO 20.03.2021 Wez wywal te rzeczy.


1 Prior to changing the CPOL/CPHA bits the SPI must be disabled by resetting the SPE bit.
2 Master and slave must be programmed with the same timing mode.
3 The idle state of SCK must correspond to the polarity selected in the SPI_CR1 register (by
pulling up SCK if CPOL=1 or pulling down SCK if CPOL=0).
4 The Data Frame Format (8- or 16-bit) is selected through the DFF bit in SPI_CR1 register,
and determines the data length during transmission/reception.

Slave select (NSS) pin management
● Software NSS management (SSM = 1)
● Hardware NSS management (SSM = 0)
"my comment:"  master uzywa GPIOsow do ustawiania NSS na slavach. Moze jednak uzywac wlasnego pinu NSS , ("SSOE=1"), aby uzyc go jak kolejne wyjscie (a la GPIO) i np zaznaczyc slave'a.
"my comment2:" dla mastera pin NSS moze byc ustawiony jako wejscie (SSOE=0) lub jako wyjscie (SSOE=1). Gdy uzywany jako wejscie, PIN jest automatycznie podciagniety do zasialnia, a slav'y zarzadzane sa softerowo. Gdy jako wyjscie, master pinem NSS zaznacza NSSa slav'e (i ustawia zbocza automatycznie na czas komunikacji)
"my comment ovr":   pin 'NSS jest konieczny dla tylko dla Slavow przy Hardware NSS Management'. 
                    'Master wowczas' moze sobie go uzywac 'jako dodatkowy GPIO (SSOE=1/0)', uwazaj tylko zeby nie dostal tam wysokiego sygnal z zewnatrz (=error). 
                    w 'multimaster-mode Master' moze potraktowac ten 'jak tak to robi slave' domyslnie.
                    w 'Software Select Management' sygnaly sa uzywany jako osobne 'GPIO' przez Slave i mastera

Clock phase and clock polarity
● The CPOL (clock polarity): ('CPOL' = 0/1): SCK pin has a low-level/high-level idle state
● CPHA (clock phase) ('CPHA' = 0/1): rising edge/falling edge if CPOL bit is reset/set is the MSBit capture strobe.

The Data Frame Format  
● Data can be shifted out either MSB-first or LSB-first depending on the value of the "LSBFIRST" bit in the "SPI_CR1" Register.
● Each data frame is 8 or 16 bits long depending on the size of the data programmed using the "DFF" bit in the "SPI_CR1" register.

Baud rate
● Select the "BR[2:0]" bits to define the serial clock baud rate (see "SPI_CR1" register).

SPI_DR
● Tx Buffer buffer przy trnasmisji
● Rx Buffer prze przy odbiorze

SPI Slave/Master conf:
conf init:          BR, CPOL,CPHA, DFF, LSBFIRST, NSS, NSTR, SPE, TXEIE, RXEIE
conf na simplex:    a) BIDIMODE(1): kierunek transmissji ustawiany przez 'BIDIOE', tylko poloczenie M:MOSI-MISO:S
                    b) BIDIMODE(0): staly kierunek ustawiany prez 'RXONLY'. polaczenie jak full duplex bez jednej linii
start:              a) master: ustawiany przez master bitem na 'SPE' (receiving) lub wrzyuceniem danych na 'SPI_DR' (transmitint).
                    b) slave: czyta ta dlugo jak jest low na 'NSS' i otrzymany 'sygnal zegarowy z mastera'
transmisja:         a) fduplex: SPE=1,SPI_DR:write,TXE:wait, SPI_DR:write, RXNE:wait,SPI_DR:read,....,RXNE:wait,SPI_DR:read,TXE:wait,BSY:wait
                    b) bidi tx/tran only: SPE=1,SPI_DR:write,TXE:wait,SPI_DR:write,...,TXE:wait,BSY:wait
                    c) bidi rx/rx only: SPE=1,RXNE:wait,SPI_DR:read,
przerwania:         'TXEIE'=1, i/lub 'RXNEIE'=1 , Robisz do tego odpowiedni wektor przerwan.

w FD miedzy receivig i transmitting jest 1 ramka odstepy: za 2 transmittem mastera, otrzymujesz pierwszy receive od slave'a
majpierw czekasz na TXE, potem na BSY
jak jest sama transmisja, to bedzie simplex trasmint ontly (jak fd bez 1 lini), wowczas wyskakiwac bede flagi OVR (trzeba je zignorowac)
